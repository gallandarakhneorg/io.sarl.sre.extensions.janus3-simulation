/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2019 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.extensions.simulation.services.lifecycle

import com.google.inject.Injector
import io.sarl.lang.core.Agent
import io.sarl.lang.core.DynamicSkillProvider
import io.sarl.sarlspecification.SarlSpecificationChecker
import io.sarl.sre.KernelScope
import io.sarl.sre.internal.SmartListenerCollection
import io.sarl.sre.services.context.Context
import io.sarl.sre.services.context.ExternalContextMemberListener
import io.sarl.sre.services.executor.ExecutorService
import io.sarl.sre.services.lifecycle.InjectionBasedLifecycleService
import io.sarl.sre.services.lifecycle.LifecycleServiceListener
import io.sarl.sre.services.lifecycle.SkillUninstaller
import io.sarl.sre.services.lifecycle.SpawnResult
import io.sarl.sre.services.logging.LoggingService
import java.util.ArrayList
import java.util.Collections
import java.util.List
import java.util.UUID
import java.util.concurrent.locks.ReadWriteLock
import java.util.logging.Level
import javax.inject.Inject
import javax.inject.Provider
import javax.inject.Singleton
import io.sarl.sre.services.lifecycle.AgentCreatorProvider

/**
 * Lifecycle service based on simulation.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * @since 0.10
 */
@Singleton
class SimulationLifecycleService extends InjectionBasedLifecycleService {

	val agents = <UUID, Agent>newTreeMap(null)

	var agentsToAdd : List<SpawnQuery> = null

	var agentsToRemove : List<Agent> = null

	val lockAdd : ReadWriteLock

	val lockDel : ReadWriteLock

	val lockRepo : ReadWriteLock

	/** 
	 * Constructs the service with the given (injected) injector.
	 * 
	 * @param injector
	 * the injector that should be used by this service for creating the agents.
	 * @param sarlSpecificationChecker the tool for checking the validity of the SARL specification supported by
	 * the agents to launch.
	 * @param skillProvider the provider of skills that should be used to init the agents.
	 * @param globalListeners is the collection of global listeners to use.
	 * @param lockProvider the provider of locks.
	 * @param lifecycleListener the listener at the platform scale on life cycle events.
	 * @param externalContextListener the listener at the platform scale on context membership events.
	 * @param skillUninstaller the object this is able to uninstall the skills.
	 * @param executor the executor service.
	 * @param logger the logging service.
	 */
	@Inject
	new (injector : Injector, sarlSpecificationChecker : SarlSpecificationChecker, skillProvider : DynamicSkillProvider,
		globalListeners : SmartListenerCollection<?>, lockProvider : Provider<ReadWriteLock>,
		@KernelScope lifecycleListener : Provider<LifecycleServiceListener>,
		@KernelScope externalContextListener : Provider<ExternalContextMemberListener>, skillUninstaller : SkillUninstaller,
		executor : ExecutorService, logger : LoggingService) {
		super(injector, sarlSpecificationChecker, skillProvider, globalListeners, lockProvider, lifecycleListener,
			externalContextListener, skillUninstaller, executor, logger)
		this.lockAdd = getLockProvider.get
		this.lockDel = getLockProvider.get
		this.lockRepo = getLockProvider.get
	}

	/** 
	 * Constructs the service.
	 * 
	 * @param sarlSpecificationChecker the tool for checking the validity of the SARL specification supported by
	 * the agents to launch.
	 * @param creator the provider of agent creators that is used when spawning agents.
	 * @param globalListeners is the collection of global listeners to use.
	 * @param lockProvider the provider of locks.
	 * @param lifecycleListener the listener at the platform scale on life cycle events.
	 * @param externalContextListener the listener at the platform scale on context membership events.
	 * @param skillUninstaller the object this is able to uninstall the skills.
	 * @param executor the executor service.
	 * @param logger the logging service.
	 */
	new (sarlSpecificationChecker : SarlSpecificationChecker, creator : AgentCreatorProvider,
		globalListeners : SmartListenerCollection<?>, lockProvider : Provider<ReadWriteLock>,
		lifecycleListener : Provider<LifecycleServiceListener>,
		externalContextListener : Provider<ExternalContextMemberListener>, skillUninstaller : SkillUninstaller,
		executor : ExecutorService, logger : LoggingService) {
		super(sarlSpecificationChecker, creator, globalListeners, lockProvider, lifecycleListener,
			externalContextListener, skillUninstaller, executor, logger)
		this.lockAdd = getLockProvider.get
		this.lockDel = getLockProvider.get
		this.lockRepo = getLockProvider.get
	}

	override spawnAgent(nbAgents : int, spawningAgent : UUID, parent : Context, agentId : UUID,
			agentClazz : Class<? extends Agent>, params : Object*) : SpawnResult {
		val ids = new ArrayList(nbAgents)
		if (nbAgents > 0) {
			if (agentId !== null) {
				ids += agentId
				for (var i = 1; i < nbAgents; i++) {
					ids += UUID::randomUUID
				}
			} else {
				for (var i = 0; i < nbAgents; i++) {
					ids += UUID::randomUUID
				}
			}
			var query = new SpawnQuery(spawningAgent, parent, ids, agentClazz, params)
			this.lockAdd.writeLock.lock
			try {
				if (this.agentsToAdd === null) {
					this.agentsToAdd = newLinkedList
				}
				this.agentsToAdd += query
			} finally {
				this.lockAdd.writeLock.unlock
			}
		}
		return new SpawnResult(ids, Collections::emptyList)
	}

	override killAgent(^agent : Agent) : boolean {
		assert ^agent !== null
		if (^agent.isKillableAgent) {
			this.lockDel.writeLock.lock
			try {
				if (this.agentsToRemove === null) {
					this.agentsToRemove = newLinkedList
				}
				this.agentsToRemove += ^agent
			} finally {
				this.lockDel.writeLock.unlock
			} 
			return true
		}
		return false
	}

	protected override onAgentCreated(^agent : Agent) {
		this.lockRepo.writeLock.lock
		try {
			this.agents.put(^agent.ID, ^agent)
		} finally {
			this.lockRepo.writeLock.unlock
		}
	}

	protected override onAgentKilled(^agent : Agent) {
		this.lockRepo.writeLock.lock
		try {
			this.agents.remove(^agent.ID)
		} finally {
			this.lockRepo.writeLock.unlock
		}
	}
	
	/** Synchronize the agent lists.
	 */
	def synchronizeAgentList {
		var addedAgents : List<SpawnQuery>
		this.lockAdd.readLock.lock
		try {
			addedAgents = this.agentsToAdd
		} finally {
			this.lockAdd.readLock.unlock
		}
		if (addedAgents !== null) {
			this.lockAdd.writeLock.lock
			try {
				addedAgents = this.agentsToAdd
				this.agentsToAdd = null
			} finally {
				this.lockAdd.writeLock.unlock
			}
			if (addedAgents !== null) {
				for (query : addedAgents) {
					var result = spawnAgent(query.agentId.size, query.spawningAgent, query.parent, query.agentClazz,
						query.params) [
						assert it >= 0
						if (it < query.agentId.size) {
							return query.agentId.get(it)
						}
						return UUID::randomUUID
					]
					if (result.error !== null) {
						loggingService.kernelLogger.log(Level::SEVERE, result.error.localizedMessage, result.error)
					}
				}
			}
		}
		var removedAgents : List<Agent>
		this.lockDel.readLock.lock
		try {
			removedAgents = this.agentsToRemove
		} finally {
			this.lockDel.readLock.unlock
		}
		if (removedAgents !== null) {
			this.lockDel.writeLock.lock
			try {
				removedAgents = this.agentsToRemove
				this.agentsToRemove = null
			} finally {
				this.lockDel.writeLock.unlock
			}
			if (removedAgents !== null) {
				for (^agent : removedAgents) {
					super.killAgent(^agent)
				}
			}
		}
	}

	/** Replies if at least one agent is running.
	 *
	 * @return {@code true} if an agent is running. Otherwise {@code false}.
	 */
	def synchronized hasAgent : boolean {
		!this.agents.empty || (this.agentsToAdd !== null && !this.agentsToAdd.empty)
	}

	/** Replies the running agents.
	 * 
	 * @return the running agents.
	 */
	def getAgents : Iterable<Agent> {
		Collections::unmodifiableCollection(this.agents.values)
	}

	protected override isEmptyRootContext(context : Context) : boolean {
		super.isEmptyRootContext(context)
		&& (this.agentsToAdd === null || this.agentsToAdd.empty)
	}

	/** Replies the agent with the identifier.
	 * 
	 * @return the agent or {@code null} if no agent exists with the given identifier.
	 */
	def getAgent(id : UUID) : Agent {
		assert id !== null
		this.agents.get(id)
	}
	
	/** 
	 * Query for creating agents.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 * @since 0.10
	 */
	private static final class SpawnQuery {

		public val spawningAgent : UUID
		public val parent : Context
		public val agentId : List<UUID>
		public val agentClazz : Class<? extends Agent>
		public val params : Object[]

		new (spawningAgent : UUID, parent : Context, agentId : List<UUID>,
			agentClazz : Class<? extends Agent>, params : Object[]) {
			this.spawningAgent = spawningAgent
			this.parent = parent
			this.agentId = agentId
			this.agentClazz = agentClazz
			this.params = params
		}

		override toString : String {
			return this.agentClazz.name
		}

	}

}
